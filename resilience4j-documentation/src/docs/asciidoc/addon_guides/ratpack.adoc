=== Ratpack Starter

This add-on provides integration with https://ratpack.io[Ratpack] libraries.

==== Gradle

Add the Ratpack Starter of Resilience4j to your compile dependency:

```
repositories {
	maven { url 'http://oss.jfrog.org/artifactory/oss-snapshot-local/' }
	mavenCentral()
}


dependencies {
	compile('io.github.resilience4j:resilience4j-ratpack:{release-version}')
	compile('io.ratpack:ratpack-guice:{ratpackVersion}')
}
```

==== Basic Usage

Installing the `Resilience4jModule` module provides a `BulkheadRegistry`,  `CircuitBreakerRegistry`, `RateLimiterRegistry`,
`RetryRegistry`, `ThreadPoolBulkheadRegistry`, and `TimeLimiterRegisty` with the default configurations. It also installs Guice method interceptors
for `Bulkheads`, `CircuitBreakers`, `RateLimiters`, `Retries`, ``ThreadPoolBulkheads`, and `TimeLimiters`. Finally, it allows configuration of metrics
and even the building of `Bulkheads`, `CircuitBreakers`, `RateLimiters`, `Retries`, `ThreadPoolBulkheads`, and `TimeLimiters`. See below for configuration details.

Note: If you don't register a `BulkheadRegistry`, `CircuitBreakerRegistry`, `RateLimiterRegistry`, `RetryRegistry`,
`ThreadPoolBulkheadRegistry`, or `TimeLimiterRegisty`, the defaults will be used.

For example

[source,java]
----
public class MyModule extends AbstractModule {

    @Override
    protected void configure() {
        CircuitBreakerConfig config = CircuitBreakerConfig.custom().build();
        bind(CircuitBreakerRegistry.class).toInstance(CircuitBreakerRegistry.of(config));
        Resilience4jModule module = new Resilience4jModule();
        module.configure(c -> {
            c.circuitBreaker("test", circuitBreakerConfig ->
                circuitBreakerConfig
                        .automaticTransitionFromOpenToHalfOpen(false)
                        .failureRateThreshold(25)
            );
        });
        install(new Resilience4jModule());
    }
}
----

==== Handlers

You can rate limit an endpoint by defining a `RateLimiterHandler` for the endpoint.

This will only rate limit the `/` endpoint.
[source,groovy]
----
ratpack {
    bindings {
        bindInstance(RateLimiterRegistry, RateLimiterRegistry.ofDefaults())
        module(Resilience4jModule)
    }
    handlers {
        get(new RateLimiterHandler(registry, 'test'))
        get {
            render 'success'
        }
        get('a') {
            render 'success'
        }
    }
}
----

This will rate limit all endpoints against the same `RateLimiter`.
[source,groovy]
----
ratpack {
    bindings {
        bindInstance(RateLimiterRegistry, RateLimiterRegistry.ofDefaults())
        module(Resilience4jModule)
    }
    handlers {
        all(new RateLimiterHandler(registry, 'test'))
        get {
            render 'success'
        }
        get('a') {
            render 'success'
        }
    }
}
----

==== Promises

Ratpack promises provide the means by which an application can become fully non-blocking and asynchronous.
Resilience4j provides transformers that can be applied to Promises. This is ideal when promising a value
that is coming from some sort of I/O source.

===== Bulkhead

You can easily apply a Bulkhead to any Ratpack Promise, given an existing `Bulkhead` instance called `bulkhead`.

[source,java]
----
public Promise<String> methodWhichReturnsAPromise() {
    return backendBConnector.methodWhichReturnsAPromise()
            .transform(BulkheadTransformer.of(bulkhead).recover(t -> "recovered"));
}
----

===== CircuitBreaker

You can easily apply a CircuitBreaker to any Ratpack Promise, given an existing `CircuitBreaker` instance called `circuitBreaker`.

[source,java]
----
public Promise<String> methodWhichReturnsAPromise() {
    return backendBConnector.methodWhichReturnsAPromise()
            .transform(CircuitBreakerTransformer.of(circuitBreaker).recover(t -> "recovered"));
}
----

You can also specify in-line which exception conditions should be recorded as a failure. In this example when
`MyException` is thrown, it will be recorded as a circuitbreaker failure. Other exceptions will be ignored by
the `circuitBreaker`.

[source,java]
----
public Promise<String> methodWhichReturnsAPromise() {
    return backendBConnector.methodWhichReturnsAPromise()
            .transform(
                CircuitBreakerTransformer
                    .of(circuitBreaker)
                    .recover(t -> "recovered")
                    .recordFailurePredicate(e -> e instanceof MyException)
            );
}
----

===== Retry

You can easily apply a Retry to any Ratpack Promise, given an existing `Retry` instance called `retry`.

[source,java]
----
public Promise<String> methodWhichReturnsAPromise() {
    return backendBConnector.methodWhichReturnsAPromise()
            .transform(RetryTransformer.of(retry).recover(t -> "recovered"));
}
----

===== RateLimiter

You can easily apply a RateLimiter to any Ratpack Promise, given an existing `RateLimiter` instance called `rateLimiter`.

[source,java]
----
public Promise<String> methodWhichReturnsAPromise() {
    return backendBConnector.methodWhichReturnsAPromise()
            .transform(RateLimiterTransformer.of(rateLimiter).recover(t -> "recovered"));
}
----

===== TimeLimiter

You can easily apply a TimeLimiter to any Ratpack Promise, given an existing `TimeLimiter` instance called `timeLimiter`.

[source,java]
----
public Promise<String> methodWhichReturnsAPromise() {
    return backendBConnector.methodWhichReturnsAPromise()
            .transform(TimeLimiterTransformer.of(timeLimiter).recover(t -> "recovered"));
}
----

==== Guice AOP

Guice provides method interception capabilities. Here are provided some annotations which support
methods returning types:

* Promise
* CompletionStage
* Flux
* Mono
* Object (except for a `TimeLimiter`, where the asynchronous nature of the timer threads are non-intuitive)

===== A Note About Fallback Methods

The `fallbackMethod` parameter signature for the annotations listed in the next sections must match either:

1) The method parameter signature on the annotated method or
2) The method parameter signature with a matching exception type as the last parameter on the annotated method

The return value can be a https://ratpack.io/manual/current/api/ratpack/exec/Promise.html[Promise],
https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletionStage.html[CompletionStage],
https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html[Flux],
https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html[Mono], or any non-reactive object type.
Other reactive types are not supported.

If the return value is one of the reactive types listed above, it must match the return value type of the annotated method.

====== Examples

Fallback for a no-params method
[source,java]
----
String fallback() {
    "recovered"
}

OR

String fallback(Throwable throwable) {
    "recovered"
}
----

Fallback for a method with a single `String` parameter
[source,java]
----
String fallback(String s) {
    "recovered"
}

OR

String fallback(String s, Throwable throwable) {
    "recovered"
}
----

`Promise` fallback
[source,java]
----
Promise<String> fallback(String s, Throwable throwable) {
    Promise.value("recovered")
}
----

`CompletionStage` fallback
[source,java]
----
CompletionStage<String> fallback(String s, Throwable throwable) {
    def future = new CompletableFuture<String>()
    future.complete("recovered")
    return future
}
----

`Flux` fallback
[source,java]
----
Flux<String> fallback(String s, Throwable throwable) {
    Flux.just("recovered")
}
----

`Mono` fallback
[source,java]
----
Mono<String> fallback(String s, Throwable throwable) {
    Mono.just("recovered")
}
----

===== Bulkhead
The demo shows how to use the `Bulkhead` annotation to have your Ratpack application limiting number of method calls.
You can either annotate a class in order to protect all public methods or just some specific methods.
For example:

[source,java]
----
@Bulkhead(name = "backendA", fallbackMethod = "fallback")
@Singleton
public class BackendAConnector implements Connector {
    ...
}
----
Where `fallbackMethod` is a method in the same class that provides
a fallback value that is returned when the bulkhead identified by `name` is full or call ends in exception.


===== CircuitBreaker
The demo shows how to use the `CircuitBreaker` annotation to make your Ratpack application more fault tolerant.
You can either annotate a class in order to protect all public methods or just some specific methods.
For example:

[source,java]
----
@CircuitBreaker(name = "backendA", fallbackMethod = "fallback")
@Singleton
public class BackendAConnector implements Connector {
    ...
}
----
Where `fallbackMethod` is a method in the same class that provides
a fallback value that is returned when the circuit breaker identified by `name` is open.

===== Retry
The demo shows how to use the `Retry` annotation to make your Ratpack application more fault tolerant.
You can either annotate a class in order to protect all public methods or just some specific methods.
For example:
`
[source,java]
----
@Retry(name = "backendA", fallbackMethod = "fallback")
@Singleton
public class BackendAConnector implements Connector {
    ...
}
----
Where `fallbackMethod` is a method in the same class that provides
a fallback value that is returned when the retry identified by `name` is has exceeded it's max calls.

===== RateLimiter
The demo shows how to use the `RateLimiter` annotation to make your Ratpack application more fault tolerant.
You can either annotate a class in order to protect all public methods or just some specific methods.
For example:

[source,java]
----
@RateLimiter(name = "backendA", fallbackMethod = "fallback")
@Singleton
public class BackendAConnector implements Connector {
    ...
}
----
Where `fallbackMethod` is a method in the same class that provides
a fallback value that is returned when the rate limiter rate limit identified by `name` is exceeded.

===== TimeLimiter
The demo shows how to use the `TimeLimiter` annotation to make your Ratpack application more fault tolerant.
You can either annotate a class in order to protect all public methods or just some specific methods.
For example:

[source,java]
----
@TimeLimiter(name = "backendA", fallbackMethod = "fallback")
@Singleton
public class BackendAConnector implements Connector {
    ...
}
----
Where `fallbackMethod` is a method in the same class that provides
a fallback value that is returned when the time limiter timeout identified by `name` is exceeded.

==== Functional style

You can still use a functional programming style for Bulkhead, CircuitBreaker, Retry, RateLimiter, and TimeLimiter. For example:

[source,java]
----
@Singleton
public class BusinessBService implements BusinessService  {

    public Try<String> methodWithRecovery() {
        CheckedFunction0<String> backendFunction = CircuitBreaker.decorateCheckedSupplier(circuitBreaker, () -> backendBConnector.failure());
        return Try.of(backendFunction)
                .recover((throwable) -> recovery(throwable));
    }

    private String recovery(Throwable throwable) {
        // Handle exception and invoke fallback
        return "Hello world from recovery";
    }

}
----

==== Adding Bulkheads, CircuitBreakers, RateLimiters, Retries, and TimeLimiters
These can be defined in the module configuration or in an external configuration.
Note that the module only provide default registries, which you can replace by
binding your own.

Module configuration example:

[source,java]
----
import java.time.Duration;

public class MyModule extends AbstractModule {

    @Override
    protected void configure() {
        Resilience4jModule module = new Resilience4jModule();
        module.configure(c -> c
            .bulkhead("test1", b -> b
                .setMaxConcurrentCalls(100)
                .setMaxWaitTime(1000)
            )
            .threadPoolBulkhead("test2", b -> b
                .setThreadPoolProperties(new ThreadPoolProperties()
                    .setMaxThreadPoolSize(2)
                    .setCoreThreadPoolSize(1)
                    .setQueueCapacity(2)
                    .setKeepAliveDuration(Duration.ofSeconds(5))
                )
            )
            .circuitBreaker("test1", cb -> cb
                .setFailureRateThreshold(50)
                .setWaitDurationInOpenState(Duration.ofMillis(5000))
                .setRingBufferSizeInClosedState(200)
                .setRingBufferSizeInHalfOpenState(20)
            )
            .rateLimiter("test1", cb -> cb
                .setLimitForPeriod(100)
                .setLimitRefreshPeriod(Duration.ofNanos(500))
                .setTimeout(Duration.ofMillis(10))
            )
            .retry("test1", cb -> cb
                .setMaxAttempts(3)
                .setWaitDuration(Duration.ofMillis(1000))
            )
            .timeLimiter("test1", cb -> cb
                .setTimeout(Duration.ofMillis(1000))
            )
        );
        install(module);
    }
}
----

External configuration example:

[source,groovy]
----
ratpack {
    serverConfig {
        yaml(getClass().classLoader.getResource('application.yml'))
        require("/resilience4j", Resilience4jConfig)
    }
    bindings {
        module(Resilience4jModule)
    }
    handlers {
        get {
            render 'ok'
        }
    }
}
----

Note that `recordFailurePredicate` cannot be specified via `yml` configuration. Instead specify `recordExceptions` and `ignoreExceptions`.
The below example will record everything exception `java.io.IOException`.

[source,yaml]
----
resilience4j:
    bulkhead:
        configs:
            default:
                maxConcurrentCalls: 50
                maxWaitTime: 500
        instances:
            test1:
                baseConfig: default
                maxWaitTime: 750
            test2:
                maxConcurrentCalls: 100
                maxWaitTime: 1000
    threadPoolBulkhead:
        configs:
            default:
                threadPoolProperties:
                    maxThreadPoolSize: 4
                    coreThreadPoolSize: 2
                    queueCapacity: 2
                    keepAliveTime: 1000
        backends:
            test1:
                baseConfig: default
            test2:
                threadPoolProperties:
                    maxThreadPoolSize: 1
                    coreThreadPoolSize: 1
                    queueCapacity: 1
                    keepAliveDuration: PT1S
    circuitBreaker:
        configs:
            default:
                ringBufferSizeInClosedState: 200
                ringBufferSizeInHalfOpenState: 20
                waitDurationInOpenState: PT1S
                failureRateThreshold: 60
                automaticTransitionFromOpenToHalfOpenEnabled: true
                recordExceptions:
                    - io.github.resilience4j.ratpack.Resilience4jModuleSpec$DummyException1
                    - io.github.resilience4j.ratpack.Resilience4jModuleSpec$DummyException2
        instances:
            test1:
                baseConfig: default
                ringBufferSizeInClosedState: 100
            test2:
                ringBufferSizeInClosedState: 200
                ringBufferSizeInHalfOpenState: 20
                waitDurationInOpenState: PT5S
                failureRateThreshold: 60
                automaticTransitionFromOpenToHalfOpenEnabled: true
                recordExceptions:
                    - io.github.resilience4j.ratpack.Resilience4jModuleSpec$DummyException1
    rateLimiter:
        configs:
            default:
                limitForPeriod: 100
                limitRefreshPeriodInNanos: 900
                timeoutInMillis: 10
        instances:
            test1:
                baseConfig: default
                limitForPeriod: 150
            test2:
                limitForPeriod: 100
                limitRefreshPeriodInNanos: 900
                timeoutInMillis: 10
    retry:
        configs:
            default:
                maxRetryAttempts: 3
                waitDurationInMillis: 1000
        instances:
            test1:
                baseConfig: default
                maxRetryAttempts: 4
            test2:
                maxRetryAttempts: 3
                waitDurationInMillis: 1000
    timeLimiter:
        configs:
            default:
                timeoutInMillis: 1000
        instances:
            test1:
                baseConfig: default
            test2:
                timeoutInMillis: 2000
----

==== Metrics
Both dropwizard and prometheus metrics can be auto configured and enabled for all registered
bulkhead instances, circuitbreaker instances, ratelimiter instances, retry instances, and timelimiter instances.

For dropwizard metrics to work, add a gradle compile dependency on resilience4j-metrics and ratpack-dropwizard-metrics
and then bind a MetricRegistry instance.

```
compile('io.github.resilience4j:resilience4j-metrics:{release-version}')
compile('io.ratpack:ratpack-dropwizard-metrics:${ratpackVersion}')
```

For prometheus metrics to work, add a gradle compile dependency on resilience4j-prometheus and
bind a CollectorRegistry instance.

```
compile('io.github.resilience4j:resilience4j-prometheus:{release-version}')
```

Enabling Dropwizard Metrics:

[source,java]
----
public class MyModule extends AbstractModule {

    @Override
    protected void configure() {
        bind(MetricRegistry.class);
        Resilience4jModule module = new Resilience4jModule();
        module.configure(c -> c.metrics(true));
        install(module);
    }
}
----

Enabling Prometheus Metrics:

[source,java]
----
public class MyModule extends AbstractModule {

    @Override
    protected void configure() {
        bind(CollectorRegistry.class);
        Resilience4jModule module = new Resilience4jModule();
        module.configure(c -> c.prometheus(true));
        install(module);
    }
}
----

==== Event Monitoring

===== Bulkhead
These are the same endpoints as implemented for Bulkhead,
so for detailed documentation please refer to previous sections.

List of available endpoints:

* `/bulkhead/events`
* `/bulkhead/stream/events`
* `/bulkhead/events/{bulkheadName}`
* `/bulkhead/stream/events/{bulkheadName}`
* `/bulkhead/events/{bulkheadName}/{eventType}`
* `/bulkhead/stream/events/{bulkheadName}/{eventType}`

Example of response:
----
{
  "bulkheadEvents": [
    {
      "bulkheadName": "backendA",
      "type": "CALL_PERMITTED",
      "creationTime": "2017-05-05T21:29:40.463+03:00[Europe/Uzhgorod]"
    },
    {
      "bulkheadName": "backendA",
      "type": "CALL_REJECTED",
      "creationTime": "2017-05-05T21:29:40.469+03:00[Europe/Uzhgorod]"
    },
    {
      "bulkheadName": "backendA",
      "type": "CALL_FINISHED",
      "creationTime": "2017-05-05T21:29:41.268+03:00[Europe/Uzhgorod]"
    }
  ]
}
----

===== CircuitBreaker

The emitted CircuitBreaker events are stored in a separate circular event consumer buffers. The size of a event consumer buffer can be configured per CircuitBreaker in the application.yml file (eventConsumerBufferSize).
The demo adds a custom Ratpack actuator endpoint which can be used to monitor the emitted events of your CircuitBreakers.
The endpoint `/circuitbreaker` lists the names of all CircuitBreaker instances.
For example:

----
{
    "circuitBreakers": [
      "backendA",
      "backendB"
    ]
}
----

The endpoint `/circuitbreaker/events` lists the latest 100 emitted events of all CircuitBreaker instances.
The endpoint `/circuitbreaker/stream/events` streams emitted events of all CircuitBreaker instances using Server-Sent Events.

----
{
"circuitBreakerEvents":[
  {
    "circuitBreakerName": "backendA",
    "type": "ERROR",
    "creationTime": "2017-01-10T15:39:17.117+01:00[Europe/Berlin]",
    "errorMessage": "org.springframework.web.client.HttpServerErrorException: 500 This is a remote exception",
    "durationInMs": 0
  },
  {
    "circuitBreakerName": "backendA",
    "type": "SUCCESS",
    "creationTime": "2017-01-10T15:39:20.518+01:00[Europe/Berlin]",
    "durationInMs": 0
  },
  {
    "circuitBreakerName": "backendB",
    "type": "ERROR",
    "creationTime": "2017-01-10T15:41:31.159+01:00[Europe/Berlin]",
    "errorMessage": "org.springframework.web.client.HttpServerErrorException: 500 This is a remote exception",
    "durationInMs": 0
  },
  {
    "circuitBreakerName": "backendB",
    "type": "SUCCESS",
    "creationTime": "2017-01-10T15:41:33.526+01:00[Europe/Berlin]",
    "durationInMs": 0
  }
]
}
----

The endpoint `/circuitbreaker/events/{circuitBreakerName}` lists the latest emitted events of a specific CircuitBreaker.
The endpoint `/circuitbreaker/stream/events/{circuitBreakerName}` streams emitted events using Server-Sent Events.
For example `/circuitbreaker/events/backendA`:

----
{
"circuitBreakerEvents":[
  {
    "circuitBreakerName": "backendA",
    "type": "ERROR",
    "creationTime": "2017-01-10T15:39:17.117+01:00[Europe/Berlin]",
    "errorMessage": "org.springframework.web.client.HttpServerErrorException: 500 This is a remote exception",
    "durationInMs": 0
  },
  {
    "circuitBreakerName": "backendA",
    "type": "SUCCESS",
    "creationTime": "2017-01-10T15:39:20.518+01:00[Europe/Berlin]",
    "durationInMs": 0
  },
  {
    "circuitBreakerName": "backendA",
    "type": "STATE_TRANSITION",
    "creationTime": "2017-01-10T15:39:22.341+01:00[Europe/Berlin]",
    "stateTransition": "CLOSED_TO_OPEN"
  },
  {
    "circuitBreakerName": "backendA",
    "type": "NOT_PERMITTED",
    "creationTime": "2017-01-10T15:39:22.780+01:00[Europe/Berlin]"
  }
]
}
----

You can even filter the list of  events.
The endpoint `/circuitbreaker/events/{circuitBreakerName}/{eventType}` lists the filtered events.
The endpoint `/circuitbreaker/stream/events/{circuitBreakerName}/{eventType}` streams emitted events using Server-Sent Events.
Event types can be:

* ERROR: A CircuitBreakerEvent which informs that an error has been recorded.
* IGNORED_ERROR: A CircuitBreakerEvent which informs that an error has been ignored.
* SUCCESS: A CircuitBreakerEvent which informs that a success has been recorded.
* NOT_PERMITTED: A CircuitBreakerEvent which informs that a call was not permitted because the CircuitBreaker state is OPEN.
* STATE_TRANSITION: A CircuitBreakerEvent which informs the state of the CircuitBreaker has been changed.

For example /circuitbreaker/events/backendA/ERROR`:
----
{
"circuitBreakerEvents":[
  {
    "circuitBreakerName": "backendA",
    "type": "ERROR",
    "creationTime": "2017-01-10T15:42:59.324+01:00[Europe/Berlin]",
    "errorMessage": "org.springframework.web.client.HttpServerErrorException: 500 This is a remote exception",
    "durationInMs": 0
  },
  {
    "circuitBreakerName": "backendA",
    "type": "ERROR",
    "creationTime": "2017-01-10T15:43:22.802+01:00[Europe/Berlin]",
    "errorMessage": "org.springframework.web.client.HttpServerErrorException: 500 This is a remote exception",
    "durationInMs": 0
  }
]
}
----

===== RateLimiter
These are the same endpoints as implemented for RateLimiter,
so for detailed documentation please refer to previous section.

List of available endpoints:

* `/ratelimiter/events`
* `/ratelimiter/stream/events`
* `/ratelimiter/events/{retryName}`
* `/ratelimiter/stream/events/{retryName}`
* `/ratelimiter/events/{retryName}/{eventType}`
* `/ratelimiter/stream/events/{retryName}/{eventType}`

Example of response:
----
{
  "rateLimiterEvents": [
    {
      "rateLimiterName": "backendA",
      "type": "SUCCESSFUL_ACQUIRE",
      "creationTime": "2017-05-05T21:29:40.463+03:00[Europe/Uzhgorod]"
    },
    {
      "rateLimiterName": "backendA",
      "type": "SUCCESSFUL_ACQUIRE",
      "creationTime": "2017-05-05T21:29:40.469+03:00[Europe/Uzhgorod]"
    },
    {
      "rateLimiterName": "backendA",
      "type": "FAILED_ACQUIRE",
      "creationTime": "2017-05-05T21:29:41.268+03:00[Europe/Uzhgorod]"
    }
  ]
}
----

===== Retry
These are the same endpoints as implemented for Retry,
so for detailed documentation please refer to previous sections.

List of available endpoints:

* `/retry/events`
* `/retry/stream/events`
* `/retry/events/{retryName}`
* `/retry/stream/events/{retryName}`
* `/retry/events/{retryName}/{eventType}`
* `/retry/stream/events/{retryName}/{eventType}`

Example of response:
----
{
  "retryEvents": [
    {
      "retryName": "backendA",
      "retryEventType": "ERROR",
      "numberOfRetryAttempts":3,
      "retryCreationTime": "2017-05-05T21:29:40.463+03:00[Europe/Uzhgorod]"
    },
    {
      "retryName": "backendA",
      "retryEventType": "ERROR",
      "numberOfRetryAttempts":3,
      "retryCreationTime": "2017-05-05T21:29:40.469+03:00[Europe/Uzhgorod]"
    },
    {
      "retryName": "backendA",
      "retryEventType": "ERROR",
      "numberOfRetryAttempts":3,
      "retryCreationTime": "2017-05-05T21:29:41.268+03:00[Europe/Uzhgorod]"
    }
  ]
}
----

===== TimeLimiter
These are the same endpoints as implemented for TimeLimiter,
so for detailed documentation please refer to previous section.

List of available endpoints:

* `/timelimiter/events`
* `/timelimiter/stream/events`
* `/timelimiter/events/{retryName}`
* `/timelimiter/stream/events/{retryName}`
* `/timelimiter/events/{retryName}/{eventType}`
* `/timelimiter/stream/events/{retryName}/{eventType}`

Example of response:
----
{
  "timeLimiterEvents": [
    {
      "timeLimiterName": "backendA",
      "type": "SUCCESS",
      "creationTime": "2020-02-13T21:42:58.757127-06:00[America/Chicago]"
    },
    {
      "timeLimiterName": "backendA",
      "type": "SUCCESS",
      "creationTime": "2020-02-13T21:42:59.262522-06:00[America/Chicago]"
    },
    {
      "timeLimiterName": "backendB",
      "type": "TIMEOUT",
      "creationTime": "2020-02-13T21:42:59.669971-06:00[America/Chicago]"
    }
  ]
}
----
